#!/usr/bin/env bash
# Use the native MacOS X/macOS mechanisms to perform forward and reverse DNS lookups
# Version: 201609013110 - Initial
# Version: 201808071148 - Updated to perform reverse lookups.
# Version: 202203040951 - A 'quiet' option when only the return code is needed.
# Version: 202303251129 - Slight reorganization and new silly commented code.
# Version: 202504061238 - Refactored for clarity and correctness.
# Version: 202601241920 - Add 'man page' like help output.
# Version: 202601310958 - Bumped to align with silly TAB edit.
# Version: 202602181706 - Tighter input validation. Not treating dscacheutil errors as success run.

set -o pipefail

SCRIPT_NAME="hostosx"
SCRIPT_VERSION="202602181706"

# Initial failure status
STAT=1
VERBOSE=YES
QUERY=""

failed() {
	echo "$0 - Script failed at line $1."
}

trap 'failed $LINENO' ERR

# Print a short usage line to stderr
print_usage() {
	echo "Usage: ${SCRIPT_NAME} [OPTIONS] QUERY" >&2
	echo "Try '${SCRIPT_NAME} --help' for more information." >&2
}

# Print help in a man-page style
print_help() {
	cat <<EOF
NAME
	${SCRIPT_NAME} — Forward and reverse DNS lookups using macOS-native mechanisms

SYNOPSIS
	${SCRIPT_NAME} [OPTIONS] QUERY

DESCRIPTION
	${SCRIPT_NAME} performs forward (name → address) and reverse (address → name)
	DNS lookups using macOS-native resolution mechanisms available to
	typical GUI apps. It avoids reliance on BSD/ISC userland tools to
	better reflect what a GUI app might get returned. See dscacheutil(1).

FEATURES
	• Forward lookup of hostnames to IP addresses
	• Reverse lookup of IPv4 and IPv6 addresses to hostnames
	• Quiet mode suitable for scripting with status-only exit codes
	• Uses dscacheutil, which queries the system's resolver configuration

OPTIONS
	-h, --help
		Show this help message and exit.

	-q	Quiet mode. Suppress output; only the exit status indicates
		success.

USAGE
	Forward lookup (hostname → address):
		${SCRIPT_NAME} example.com

	Reverse lookup (IPv4 → name):
		${SCRIPT_NAME} 104.18.26.120

	Reverse lookup (IPv6 → name):
		${SCRIPT_NAME} 2606:4700::6812:1b78

	Quiet mode (status only):
		${SCRIPT_NAME} -q example.com

EXIT STATUS
	0   A result was obtained and printed (unless -q was used).
	1   No result was found or an error occurred.

SEE ALSO
	dscacheutil(1)
	
${SCRIPT_NAME}								${SCRIPT_VERSION}

EOF
}

# Validate IPv4 addresses
is_valid_ipv4() {
	local IFS=.
	local -a parts
	read -r -a parts <<< "$1"
	[[ ${#parts[@]} -eq 4 ]] || return 1
	for octet in "${parts[@]}"; do
		[[ $octet =~ ^[0-9]+$ ]] || return 1
		(( octet >= 0 && octet <= 255 )) || return 1
	done
	return 0
}

# Validate IPv6 addresses using regex
is_valid_ipv6() {
	local regex='^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9]))\.){3}(25[0-5]|(2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9]))|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9]))\.){3}(25[0-5]|(2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])))$'
	[[ "$1" =~ $regex ]]
}

# Validate hostnames/FQDNs (RFC 1035/1123-style ASCII)
is_valid_hostname() {
	local host="$1"
	local host_nodot
	local label

	# Reject empty, leading dash, or any whitespace/control chars
	[[ -n "$host" ]] || return 1
	[[ "$host" == -* ]] && return 1
	[[ "$host" =~ [[:space:][:cntrl:]] ]] && return 1
	[[ "$host" =~ ^[A-Za-z0-9.-]+$ ]] || return 1

	# Strip trailing dot for FQDN validation length rules
	host_nodot="${host%.}"

	# Total length max 253 (without trailing dot)
	((${#host_nodot} <= 253)) || return 1

	IFS='.' read -r -a parts <<< "$host_nodot"
	[[ ${#parts[@]} -gt 0 ]] || return 1
	for label in "${parts[@]}"; do
		# Each label 1-63, starts/ends alnum, interior can include hyphen
		((${#label} >= 1 && ${#label} <= 63)) || return 1
		[[ "$label" =~ ^[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?$ ]] || return 1
	done
	return 0
}

# Parse options
while [[ $# -gt 0 ]]; do
	case "$1" in
		-h|--help)
			print_help
			exit 0
			;;
		-q)
			VERBOSE=NO
			shift
			;;
		--)
			shift
			break
			;;
		-*)
			echo "${SCRIPT_NAME}: unrecognized option '$1'" >&2
			print_usage
			exit 1
			;;
		*)
			# First non-option is the query
			if [[ -z "$QUERY" ]]; then
				QUERY="$1"
			else
				echo "${SCRIPT_NAME}: too many arguments: '$1'" >&2
				print_usage
				exit 1
			fi
			shift
			;;
	esac
	# Only shift here for options that don't already shifted
	# Note: -q has already shifted once to consume itself
	if [[ "$1" != "" && "$1" != "-q" ]]; then
		:
	fi
	continue
done

if [[ -z "$QUERY" && $# -gt 0 ]]; then
	QUERY="$1"
	shift
fi
if [[ $# -gt 0 ]]; then
	echo "${SCRIPT_NAME}: too many arguments: '$*'" >&2
	print_usage
	exit 1
fi

# Require a query argument
if [[ -z "$QUERY" ]]; then
	print_usage
	exit 1
fi

# Validate query format before invoking dscacheutil
if ! is_valid_ipv4 "$QUERY" && ! is_valid_ipv6 "$QUERY" && ! is_valid_hostname "$QUERY"; then
	echo "${SCRIPT_NAME}: invalid lookup string: '$QUERY'" >&2
	echo "${SCRIPT_NAME}: expected RFC-compliant hostname/FQDN or IPv4/IPv6 address" >&2
	exit 1
fi

# Perform the appropriate lookup
if is_valid_ipv4 "$QUERY"; then
	if LOOKUPRESULT="$(dscacheutil -q host -a ip_address "$QUERY")"; then
		:
	else
		LOOKUPRESULT=""
	fi
elif is_valid_ipv6 "$QUERY"; then
	if LOOKUPRESULT="$(dscacheutil -q host -a ip_address "$QUERY")"; then
		:
	else
		LOOKUPRESULT=""
	fi
else
	if LOOKUPRESULT="$(dscacheutil -q host -a name "$QUERY")"; then
		:
	else
		LOOKUPRESULT=""
	fi
fi

# Output results and set status
if [[ -n "$LOOKUPRESULT" ]]; then
	[[ "$VERBOSE" == YES ]] && echo "$LOOKUPRESULT"
	STAT=0
fi

exit "$STAT"
