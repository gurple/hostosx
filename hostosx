#!/usr/bin/env bash
# Use the native MacOS X/macOS mechanisms to perform forward and reverse DNS lookups
# Version: 201609013110 - Initial
# Version: 201808071148 - Updated to perform reverse lookups.
# Version: 202203040951 - A 'quiet' option when only the return code is needed.
# Version: 202303251129 - Slight reorganization and new silly commented code.
# Version: 202504061238 - Refactored for clarity and correctness.
# Version: 202601241920 - Add 'man page' like help output.

set -o pipefail

SCRIPT_NAME="hostosx"
SCRIPT_VERSION="202601241920"

# Initial failure status
STAT=1
VERBOSE=YES
QUERY=""

# Print a short usage line to stderr
print_usage() {
	echo "Usage: ${SCRIPT_NAME} [OPTIONS] QUERY" >&2
	echo "Try '${SCRIPT_NAME} --help' for more information." >&2
}

# Print help in a man-page style
print_help() {
	cat <<EOF
NAME
	${SCRIPT_NAME} — Forward and reverse DNS lookups using macOS-native mechanisms

SYNOPSIS
	${SCRIPT_NAME} [OPTIONS] QUERY

DESCRIPTION
	${SCRIPT_NAME} performs forward (name → address) and reverse (address → name)
	DNS lookups using macOS-native resolution mechanisms available to
	typical GUI apps. It avoids reliance on BSD/ISC userland tools to
	better reflect what a GUI app might get returned. See dscacheutil(1).

FEATURES
	• Forward lookup of hostnames to IP addresses
	• Reverse lookup of IPv4 and IPv6 addresses to hostnames
	• Quiet mode suitable for scripting with status-only exit codes
	• Uses dscacheutil, which queries the system's resolver configuration

OPTIONS
	-h, --help
		Show this help message and exit.

	-q	Quiet mode. Suppress output; only the exit status indicates
		success.

USAGE
	Forward lookup (hostname → address):
		${SCRIPT_NAME} example.com

	Reverse lookup (IPv4 → name):
		${SCRIPT_NAME} 104.18.26.120

	Reverse lookup (IPv6 → name):
		${SCRIPT_NAME} 2606:4700::6812:1b78

	Quiet mode (status only):
		${SCRIPT_NAME} -q example.com

EXIT STATUS
	0   A result was obtained and printed (unless -q was used).
	1   No result was found or an error occurred.

SEE ALSO
	dscacheutil(1)
	
${SCRIPT_NAME}								${SCRIPT_VERSION}

EOF
}

# Validate IPv4 addresses
is_valid_ipv4() {
     local IFS=.
     local -a parts
     read -r -a parts <<< "$1"
     [[ ${#parts[@]} -eq 4 ]] || return 1
     for octet in "${parts[@]}"; do
       [[ $octet =~ ^[0-9]+$ ]] || return 1
       (( octet >= 0 && octet <= 255 )) || return 1
     done
     return 0
   }

# Validate IPv6 addresses using regex
is_valid_ipv6() {
	local regex='^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9]))\.){3}(25[0-5]|(2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9]))|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9]))\.){3}(25[0-5]|(2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])))$'
	[[ "$1" =~ $regex ]]
}

# Parse options
while [[ $# -gt 0 ]]; do
	case "$1" in
		-h|--help)
			print_help
			exit 0
			;;
		-q)
			VERBOSE=NO
			shift
			;;
		--)
			shift
			break
			;;
		-*)
			echo "${SCRIPT_NAME}: unrecognized option '$1'" >&2
			print_usage
			exit 1
			;;
		*)
			# First non-option is the query
			if [[ -z "$QUERY" ]]; then
				QUERY="$1"
			else
				echo "${SCRIPT_NAME}: too many arguments: '$1'" >&2
				print_usage
				exit 1
			fi
			shift
			;;
	esac
	# Only shift here for options that don't already shifted
	# Note: -q has already shifted once to consume itself
	if [[ "$1" != "" && "$1" != "-q" ]]; then
		:
	fi
	continue
done

if [[ -z "$QUERY" && $# -gt 0 ]]; then
	QUERY="$1"
	shift
fi
if [[ $# -gt 0 ]]; then
	echo "${SCRIPT_NAME}: too many arguments: '$*'" >&2
	print_usage
	exit 1
fi

# Require a query argument
if [[ -z "$QUERY" ]]; then
	print_usage
	exit 1
fi

# Perform the appropriate lookup
if is_valid_ipv4 "$QUERY"; then
	LOOKUPRESULT="$(dscacheutil -q host -a ip_address "$QUERY")"
elif is_valid_ipv6 "$QUERY"; then
	LOOKUPRESULT="$(dscacheutil -q host -a ip_address "$QUERY")"
else
	LOOKUPRESULT="$(dscacheutil -q host -a name "$QUERY")"
fi

# Output results and set status
if [[ -n "$LOOKUPRESULT" ]]; then
	[[ "$VERBOSE" == YES ]] && echo "$LOOKUPRESULT"
	STAT=0
fi

exit "$STAT"

